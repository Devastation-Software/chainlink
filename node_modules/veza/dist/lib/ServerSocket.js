"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSocket = exports.ServerSocketStatus = void 0;
const SocketHandler_1 = require("./Structures/Base/SocketHandler");
const MessageError_1 = require("./Structures/MessageError");
const Shared_1 = require("./Util/Shared");
/**
 * The connection status of this socket.
 * @since 0.7.0
 */
var ServerSocketStatus;
(function (ServerSocketStatus) {
    /**
     * The connected status, the socket is connected and identified.
     * @since 0.7.0
     */
    ServerSocketStatus[ServerSocketStatus["Connected"] = 0] = "Connected";
    /**
     * The identifying status, the socket has connected but has not identified yet.
     * @since 0.7.0
     */
    ServerSocketStatus[ServerSocketStatus["Identifiying"] = 1] = "Identifiying";
    /**
     * The disconnected status, the socket has been disconnected and cannot operate anymore.
     * @since 0.7.0
     */
    ServerSocketStatus[ServerSocketStatus["Disconnected"] = 2] = "Disconnected";
})(ServerSocketStatus = exports.ServerSocketStatus || (exports.ServerSocketStatus = {}));
class ServerSocket extends SocketHandler_1.SocketHandler {
    constructor(server, socket) {
        super(null, socket);
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ServerSocketStatus.Disconnected
        });
        this.server = server;
    }
    async setup() {
        this.status = ServerSocketStatus.Identifiying;
        this.socket.on('data', this._onData.bind(this)).on('error', this._onError.bind(this)).on('close', this._onClose.bind(this));
        try {
            const sName = await this.send(this.server.name);
            // sName must never be anything that is not a string
            if (typeof sName !== 'string') {
                return this.disconnect();
            }
            this.status = ServerSocketStatus.Connected;
            this.name = sName;
            // Disconnect if a previous socket existed.
            const existing = this.server.sockets.get(sName);
            if (existing) {
                existing.disconnect(true);
            }
            // Add this socket to the clients.
            this.server.sockets.set(sName, this);
            return this.server.emit('connect', this);
        }
        catch {
            return this.disconnect();
        }
    }
    /**
     * Disconnect from the socket, this will also reject all messages
     */
    disconnect(close) {
        if (this.status === ServerSocketStatus.Disconnected)
            return false;
        if (close)
            this.socket.end(Shared_1.VCLOSE);
        this.socket.destroy();
        if (this.queue.size) {
            const rejectError = new Error('Socket has been disconnected.');
            for (const element of this.queue.values())
                element.reject(rejectError);
        }
        this.status = ServerSocketStatus.Disconnected;
        if (this.name) {
            this.server.sockets.delete(this.name);
        }
        this.socket.removeAllListeners();
        this.server.emit('disconnect', this);
        return true;
    }
    _onData(data) {
        this.server.emit('raw', data, this);
        for (const processed of this.queue.process(data)) {
            if (processed.id === null) {
                if (this.status === ServerSocketStatus.Connected) {
                    this.server.emit('error', (0, MessageError_1.makeError)('Failed to parse message', processed.data), this);
                }
                else {
                    this.server.emit('error', (0, MessageError_1.makeError)('Failed to process message during connection, calling disconnect', processed.data), this);
                    this.disconnect();
                }
            }
            else {
                const message = this._handleMessage(processed);
                if (message)
                    this.server.emit('message', message, this);
            }
        }
    }
    _onError(error) {
        this.server.emit('error', error, this);
    }
    _onClose() {
        this.disconnect();
    }
}
exports.ServerSocket = ServerSocket;
//# sourceMappingURL=ServerSocket.js.map