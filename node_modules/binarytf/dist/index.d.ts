/// <reference lib="dom" />
interface OnUnsupported {
    (value: unknown): unknown;
}
declare class Serializer {
    onUnsupported: OnUnsupported | null;
    private _buffer;
    private _offset;
    private _objectIDs;
    private _data;
    private _handlingUnsupported;
    constructor(data: any, onUnsupported?: OnUnsupported | null);
    process(): Uint8Array;
    parse(value: any, hint?: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"): void;
    protected handleUnsupported(value: unknown, hint: string): void;
    private parseBigInt;
    private parseBoolean;
    private parseNumber;
    private parseObject;
    private parseString;
    private parseUndefined;
    private parseValueNull;
    private parseValueObjectString;
    private parseValueObjectBoolean;
    private parseValueObjectNumber;
    private parseValueObjectDate;
    private parseValueObjectRegExp;
    private parseValueObjectLiteral;
    private parseValueObjectMap;
    private parseValueObjectSet;
    private parseValueObjectArrayBuffer;
    private parseValueObjectWeakMap;
    private parseValueObjectWeakSet;
    private parseValueObjectFallback;
    private parseValueReference;
    private parseValueArray;
    private writeValueTypedArray;
    private write;
    private write8;
    private write32;
    private write32At;
    private writeF64;
    private writeValueString;
    private getNumberType;
    private ensureAlloc;
    private expandBuffer;
    private static _textEncoder;
}

/// <reference lib="dom" />
declare class Deserializer {
    offset: number;
    private _buffer;
    private _objectIDs;
    constructor(buffer: Uint8Array);
    private get finished();
    clean(): void;
    read(): string | number | bigint | boolean | Record<any, any> | null | undefined;
    private readValueTypedArray;
    private readValueArrayBuffer;
    private readValueSet;
    private readValueMap;
    private readValueObject;
    private readValueArray;
    private readString;
    private readValueBigInt;
    private readNullTerminator;
    private createObjectID;
    private offsetBack;
    private watch8;
    private read8;
    private read32;
    private readF64;
    private ensureBytes;
    private static _textDecoder;
}

declare class DeserializerError extends Error {
    kind: DeserializerReason;
    constructor(message: string, kind: DeserializerReason);
}
declare enum DeserializerReason {
    UnknownType = "UnknownType",
    UnexpectedEndOfBuffer = "UnexpectedEndOfBuffer"
}

declare class SerializerError extends Error {
    kind: SerializerReason;
    constructor(message: string, kind: SerializerReason);
}
declare enum SerializerReason {
    UnsupportedType = "UnsupportedType",
    UnsupportedSerializedType = "UnsupportedSerializedType",
    UnexpectedNullValue = "UnexpectedNullValue"
}

declare enum BinaryTokens {
    NullPointer = 0,
    Hole = 1,
    Null = 2,
    PBigInt = 3,
    NBigInt = 4,
    Boolean = 5,
    String = 6,
    Undefined = 7,
    UnsignedByte = 8,
    SignedByte = 9,
    UnsignedInt32 = 10,
    SignedInt32 = 11,
    UnsignedFloat64 = 12,
    SignedFloat64 = 13,
    Array = 14,
    EmptyArray = 15,
    ObjectReference = 16,
    Date = 17,
    BooleanObject = 18,
    NumberObject = 19,
    StringObject = 20,
    EmptyObject = 21,
    Object = 22,
    RegExp = 23,
    Map = 24,
    EmptyMap = 25,
    WeakMap = 26,
    Set = 27,
    EmptySet = 28,
    WeakSet = 29,
    ArrayBuffer = 30,
    Int8Array = 31,
    Uint8Array = 32,
    Uint8ClampedArray = 33,
    Int16Array = 34,
    Uint16Array = 35,
    Int32Array = 36,
    Uint32Array = 37,
    Float32Array = 38,
    Float64Array = 39,
    DataView = 40
}
declare enum BinaryPrimitives {
    BigInt = "bigint",
    Boolean = "boolean",
    Number = "number",
    Object = "object",
    String = "string",
    Undefined = "undefined"
}
declare type TypedArray = Uint8Array | Float32Array | Int32Array;
declare const TypedArray: TypedArray;

declare namespace RegExps {
    function flagsAsInteger(regExp: RegExp): number;
    function flagsFromInteger(integer: number): string;
}
declare namespace BigIntegers {
    const SUPPORTED: boolean;
    const ZERO: bigint | null;
    const ONE: bigint | null;
    const EIGHT: bigint | null;
    const BYTE: bigint | null;
}
declare namespace Numbers {
    function nextPowerOfTwo(n: number): number;
}
declare namespace TypedArrays {
    const constructors: (new <T extends TypedArray>(...args: any) => T)[];
    const typedArrayTags: Map<string, BinaryTokens>;
    const typedArrayTagToConstructor: Map<BinaryTokens, new <T extends TypedArray>(...args: any) => T>;
}

declare function serialize<T = unknown>(data: T, onUnsupported?: OnUnsupported): Uint8Array;
declare function deserialize<T = unknown>(buffer: Uint8Array, offset?: number): T;
declare function deserializeWithMetadata<T = unknown>(buffer: Uint8Array, offset?: number): {
    value: T;
    offset: number;
};

export { BigIntegers, BinaryPrimitives, BinaryTokens, Deserializer, DeserializerError, DeserializerReason, Numbers, OnUnsupported, RegExps, Serializer, SerializerError, SerializerReason, TypedArray, TypedArrays, deserialize, deserializeWithMetadata, serialize };
