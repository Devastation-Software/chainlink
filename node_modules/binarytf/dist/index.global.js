"use strict";
var BinaryTF = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    BigIntegers: () => BigIntegers,
    BinaryPrimitives: () => BinaryPrimitives,
    BinaryTokens: () => BinaryTokens,
    Deserializer: () => Deserializer,
    DeserializerError: () => DeserializerError,
    DeserializerReason: () => DeserializerReason,
    Numbers: () => Numbers,
    RegExps: () => RegExps,
    Serializer: () => Serializer,
    SerializerError: () => SerializerError,
    SerializerReason: () => SerializerReason,
    TypedArray: () => TypedArray,
    TypedArrays: () => TypedArrays,
    deserialize: () => deserialize,
    deserializeWithMetadata: () => deserializeWithMetadata,
    serialize: () => serialize
  });

  // src/lib/errors/DeserializerError.ts
  var DeserializerError = class extends Error {
    constructor(message, kind) {
      super(message);
      this.kind = kind;
    }
  };
  __name(DeserializerError, "DeserializerError");
  var DeserializerReason = /* @__PURE__ */ ((DeserializerReason2) => {
    DeserializerReason2["UnknownType"] = "UnknownType";
    DeserializerReason2["UnexpectedEndOfBuffer"] = "UnexpectedEndOfBuffer";
    return DeserializerReason2;
  })(DeserializerReason || {});

  // src/lib/util/constants.ts
  var BinaryTokens = /* @__PURE__ */ ((BinaryTokens2) => {
    BinaryTokens2[BinaryTokens2["NullPointer"] = 0] = "NullPointer";
    BinaryTokens2[BinaryTokens2["Hole"] = 1] = "Hole";
    BinaryTokens2[BinaryTokens2["Null"] = 2] = "Null";
    BinaryTokens2[BinaryTokens2["PBigInt"] = 3] = "PBigInt";
    BinaryTokens2[BinaryTokens2["NBigInt"] = 4] = "NBigInt";
    BinaryTokens2[BinaryTokens2["Boolean"] = 5] = "Boolean";
    BinaryTokens2[BinaryTokens2["String"] = 6] = "String";
    BinaryTokens2[BinaryTokens2["Undefined"] = 7] = "Undefined";
    BinaryTokens2[BinaryTokens2["UnsignedByte"] = 8] = "UnsignedByte";
    BinaryTokens2[BinaryTokens2["SignedByte"] = 9] = "SignedByte";
    BinaryTokens2[BinaryTokens2["UnsignedInt32"] = 10] = "UnsignedInt32";
    BinaryTokens2[BinaryTokens2["SignedInt32"] = 11] = "SignedInt32";
    BinaryTokens2[BinaryTokens2["UnsignedFloat64"] = 12] = "UnsignedFloat64";
    BinaryTokens2[BinaryTokens2["SignedFloat64"] = 13] = "SignedFloat64";
    BinaryTokens2[BinaryTokens2["Array"] = 14] = "Array";
    BinaryTokens2[BinaryTokens2["EmptyArray"] = 15] = "EmptyArray";
    BinaryTokens2[BinaryTokens2["ObjectReference"] = 16] = "ObjectReference";
    BinaryTokens2[BinaryTokens2["Date"] = 17] = "Date";
    BinaryTokens2[BinaryTokens2["BooleanObject"] = 18] = "BooleanObject";
    BinaryTokens2[BinaryTokens2["NumberObject"] = 19] = "NumberObject";
    BinaryTokens2[BinaryTokens2["StringObject"] = 20] = "StringObject";
    BinaryTokens2[BinaryTokens2["EmptyObject"] = 21] = "EmptyObject";
    BinaryTokens2[BinaryTokens2["Object"] = 22] = "Object";
    BinaryTokens2[BinaryTokens2["RegExp"] = 23] = "RegExp";
    BinaryTokens2[BinaryTokens2["Map"] = 24] = "Map";
    BinaryTokens2[BinaryTokens2["EmptyMap"] = 25] = "EmptyMap";
    BinaryTokens2[BinaryTokens2["WeakMap"] = 26] = "WeakMap";
    BinaryTokens2[BinaryTokens2["Set"] = 27] = "Set";
    BinaryTokens2[BinaryTokens2["EmptySet"] = 28] = "EmptySet";
    BinaryTokens2[BinaryTokens2["WeakSet"] = 29] = "WeakSet";
    BinaryTokens2[BinaryTokens2["ArrayBuffer"] = 30] = "ArrayBuffer";
    BinaryTokens2[BinaryTokens2["Int8Array"] = 31] = "Int8Array";
    BinaryTokens2[BinaryTokens2["Uint8Array"] = 32] = "Uint8Array";
    BinaryTokens2[BinaryTokens2["Uint8ClampedArray"] = 33] = "Uint8ClampedArray";
    BinaryTokens2[BinaryTokens2["Int16Array"] = 34] = "Int16Array";
    BinaryTokens2[BinaryTokens2["Uint16Array"] = 35] = "Uint16Array";
    BinaryTokens2[BinaryTokens2["Int32Array"] = 36] = "Int32Array";
    BinaryTokens2[BinaryTokens2["Uint32Array"] = 37] = "Uint32Array";
    BinaryTokens2[BinaryTokens2["Float32Array"] = 38] = "Float32Array";
    BinaryTokens2[BinaryTokens2["Float64Array"] = 39] = "Float64Array";
    BinaryTokens2[BinaryTokens2["DataView"] = 40] = "DataView";
    return BinaryTokens2;
  })(BinaryTokens || {});
  var BinaryPrimitives = /* @__PURE__ */ ((BinaryPrimitives2) => {
    BinaryPrimitives2["BigInt"] = "bigint";
    BinaryPrimitives2["Boolean"] = "boolean";
    BinaryPrimitives2["Number"] = "number";
    BinaryPrimitives2["Object"] = "object";
    BinaryPrimitives2["String"] = "string";
    BinaryPrimitives2["Undefined"] = "undefined";
    return BinaryPrimitives2;
  })(BinaryPrimitives || {});
  var TypedArray = Object.getPrototypeOf(Int8Array);

  // src/lib/util/util.ts
  var RegExps;
  ((RegExps2) => {
    const g = 1 << 0;
    const i = 1 << 1;
    const m = 1 << 2;
    const y = 1 << 3;
    const u = 1 << 4;
    const s = 1 << 5;
    function flagsAsInteger(regExp) {
      return (regExp.global ? g : 0) | (regExp.ignoreCase ? i : 0) | (regExp.multiline ? m : 0) | (regExp.sticky ? y : 0) | (regExp.unicode ? u : 0) | (regExp.dotAll ? s : 0);
    }
    RegExps2.flagsAsInteger = flagsAsInteger;
    __name(flagsAsInteger, "flagsAsInteger");
    function flagsFromInteger(integer) {
      let ret = "";
      if (integer & g)
        ret += "g";
      if (integer & i)
        ret += "i";
      if (integer & m)
        ret += "m";
      if (integer & y)
        ret += "y";
      if (integer & u)
        ret += "u";
      if (integer & s)
        ret += "s";
      return ret;
    }
    RegExps2.flagsFromInteger = flagsFromInteger;
    __name(flagsFromInteger, "flagsFromInteger");
  })(RegExps || (RegExps = {}));
  var BigIntegers;
  ((BigIntegers2) => {
    BigIntegers2.SUPPORTED = typeof BigInt === "function";
    BigIntegers2.ZERO = BigIntegers2.SUPPORTED ? BigInt(0) : null;
    BigIntegers2.ONE = BigIntegers2.SUPPORTED ? BigInt(1) : null;
    BigIntegers2.EIGHT = BigIntegers2.SUPPORTED ? BigInt(8) : null;
    BigIntegers2.BYTE = BigIntegers2.SUPPORTED ? BigInt(255) : null;
  })(BigIntegers || (BigIntegers = {}));
  var Numbers;
  ((Numbers2) => {
    function nextPowerOfTwo(n) {
      return Math.pow(2, Math.ceil(Math.log2(n)));
    }
    Numbers2.nextPowerOfTwo = nextPowerOfTwo;
    __name(nextPowerOfTwo, "nextPowerOfTwo");
  })(Numbers || (Numbers = {}));
  var TypedArrays;
  ((TypedArrays2) => {
    TypedArrays2.constructors = [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      DataView
    ];
    if (typeof BigInt64Array === "function")
      TypedArrays2.constructors.push(BigInt64Array);
    if (typeof BigUint64Array === "function")
      TypedArrays2.constructors.push(BigUint64Array);
    TypedArrays2.typedArrayTags = new Map(TypedArrays2.constructors.map((typedArray) => [Object.prototype.toString.call(new typedArray(new ArrayBuffer(0))), BinaryTokens[typedArray.name]]));
    TypedArrays2.typedArrayTagToConstructor = new Map(TypedArrays2.constructors.map((typedArray) => [BinaryTokens[typedArray.name], typedArray]));
  })(TypedArrays || (TypedArrays = {}));

  // src/lib/Deserializer.ts
  var float64Array = new Float64Array(1);
  var uInt8Float64Array = new Uint8Array(float64Array.buffer);
  var _Deserializer = class {
    constructor(buffer) {
      this.offset = 0;
      this._objectIDs = /* @__PURE__ */ new Map();
      this._buffer = buffer;
    }
    get finished() {
      return this.offset === this._buffer.length;
    }
    clean() {
      this._buffer = null;
      this.offset = 0;
      this._objectIDs.clear();
    }
    read() {
      const type = this.read8();
      switch (type) {
        case 2 /* Null */:
          return null;
        case 3 /* PBigInt */:
          return this.readValueBigInt(false);
        case 4 /* NBigInt */:
          return this.readValueBigInt(true);
        case 5 /* Boolean */:
          return Boolean(this.read8());
        case 6 /* String */:
          return this.readString();
        case 7 /* Undefined */:
          return void 0;
        case 8 /* UnsignedByte */:
          return this.read8();
        case 9 /* SignedByte */:
          return -this.read8();
        case 10 /* UnsignedInt32 */:
          return this.read32();
        case 11 /* SignedInt32 */:
          return -this.read32();
        case 12 /* UnsignedFloat64 */:
          return this.readF64();
        case 13 /* SignedFloat64 */:
          return -this.readF64();
        case 14 /* Array */:
          return this.readValueArray();
        case 15 /* EmptyArray */:
          return this.createObjectID([]);
        case 16 /* ObjectReference */:
          return this._objectIDs.get(this.read32());
        case 17 /* Date */:
          return this.createObjectID(new Date(this.readF64()));
        case 18 /* BooleanObject */:
          return this.createObjectID(new Boolean(this.read8()));
        case 19 /* NumberObject */:
          return this.createObjectID(new Number(this.readF64()));
        case 20 /* StringObject */:
          return this.createObjectID(new String(this.readString()));
        case 21 /* EmptyObject */:
          return this.createObjectID({});
        case 22 /* Object */:
          return this.readValueObject();
        case 23 /* RegExp */:
          return this.createObjectID(new RegExp(this.readString(), RegExps.flagsFromInteger(this.read8())));
        case 24 /* Map */:
          return this.readValueMap();
        case 25 /* EmptyMap */:
          return this.createObjectID(/* @__PURE__ */ new Map());
        case 27 /* Set */:
          return this.readValueSet();
        case 28 /* EmptySet */:
          return this.createObjectID(/* @__PURE__ */ new Set());
        case 30 /* ArrayBuffer */:
          return this.readValueArrayBuffer();
        case 26 /* WeakMap */:
          return this.createObjectID(/* @__PURE__ */ new WeakMap());
        case 29 /* WeakSet */:
          return this.createObjectID(/* @__PURE__ */ new WeakSet());
        case 31 /* Int8Array */:
        case 32 /* Uint8Array */:
        case 33 /* Uint8ClampedArray */:
        case 34 /* Int16Array */:
        case 35 /* Uint16Array */:
        case 36 /* Int32Array */:
        case 37 /* Uint32Array */:
        case 38 /* Float32Array */:
        case 39 /* Float64Array */:
        case 40 /* DataView */:
          return this.readValueTypedArray(type);
        default:
          throw new DeserializerError(`Unknown type received: ${type}`, "UnknownType" /* UnknownType */);
      }
    }
    readValueTypedArray(token) {
      const byteLength = this.read32();
      this.ensureBytes(byteLength);
      let value;
      if (token === 32 /* Uint8Array */) {
        value = this._buffer.subarray(this.offset, this.offset + byteLength);
      } else {
        const buffer = new ArrayBuffer(byteLength);
        const ctor = TypedArrays.typedArrayTagToConstructor.get(token);
        value = new ctor(buffer);
        new Uint8Array(buffer).set(this._buffer.subarray(this.offset, this.offset + byteLength));
      }
      this.offset += byteLength;
      return this.createObjectID(value);
    }
    readValueArrayBuffer() {
      const value = this.createObjectID(new ArrayBuffer(this.read32()));
      const uint8Array = new Uint8Array(value);
      for (let i = 0, max = uint8Array.length; i < max; i++) {
        uint8Array[i] = this.read8();
      }
      return value;
    }
    readValueSet() {
      const value = this.createObjectID(/* @__PURE__ */ new Set());
      while (!this.readNullTerminator()) {
        value.add(this.read());
      }
      return value;
    }
    readValueMap() {
      const value = this.createObjectID(/* @__PURE__ */ new Map());
      while (!this.readNullTerminator()) {
        value.set(this.read(), this.read());
      }
      return value;
    }
    readValueObject() {
      const value = this.createObjectID({});
      while (!this.readNullTerminator()) {
        const entryKey = this.read();
        const entryValue = this.read();
        value[entryKey] = entryValue;
      }
      return value;
    }
    readValueArray() {
      const value = this.createObjectID([]);
      let i = 0;
      while (!this.readNullTerminator()) {
        if (this.read8() !== 1 /* Hole */) {
          this.offsetBack();
          value[i] = this.read();
        }
        ++i;
      }
      value.length = i;
      return value;
    }
    readString() {
      const end = this._buffer.indexOf(0 /* NullPointer */, this.offset);
      if (end === -1) {
        throw new DeserializerError("Found End-Of-Buffer, expecting a `NullTerminator` before.", "UnexpectedEndOfBuffer" /* UnexpectedEndOfBuffer */);
      }
      const sub = this._buffer.subarray(this.offset, end);
      const str = _Deserializer._textDecoder.decode(sub);
      this.offset = end + 1;
      return str;
    }
    readValueBigInt(sign) {
      const byteLength = this.read32();
      let value = BigIntegers.ZERO;
      let b = BigIntegers.ONE;
      for (let i = 0; i < byteLength; i++) {
        const digit = this.read8();
        value += BigInt(digit) * b;
        b <<= BigIntegers.EIGHT;
      }
      return sign ? -value : value;
    }
    readNullTerminator() {
      if (this.watch8() === 0 /* NullPointer */) {
        ++this.offset;
        return true;
      } else if (this.finished) {
        throw new DeserializerError("Found End-Of-Buffer, expecting a `NullTerminator` before.", "UnexpectedEndOfBuffer" /* UnexpectedEndOfBuffer */);
      }
      return false;
    }
    createObjectID(value) {
      this._objectIDs.set(this._objectIDs.size, value);
      return value;
    }
    offsetBack() {
      --this.offset;
    }
    watch8() {
      return this._buffer[this.offset];
    }
    read8() {
      this.ensureBytes(1);
      return this._buffer[this.offset++];
    }
    read32() {
      this.ensureBytes(4);
      return this._buffer[this.offset++] * 2 ** 24 + this._buffer[this.offset++] * 2 ** 16 + this._buffer[this.offset++] * 2 ** 8 + this._buffer[this.offset++];
    }
    readF64() {
      this.ensureBytes(8);
      uInt8Float64Array[0] = this._buffer[this.offset++];
      uInt8Float64Array[1] = this._buffer[this.offset++];
      uInt8Float64Array[2] = this._buffer[this.offset++];
      uInt8Float64Array[3] = this._buffer[this.offset++];
      uInt8Float64Array[4] = this._buffer[this.offset++];
      uInt8Float64Array[5] = this._buffer[this.offset++];
      uInt8Float64Array[6] = this._buffer[this.offset++];
      uInt8Float64Array[7] = this._buffer[this.offset++];
      return float64Array[0];
    }
    ensureBytes(amount) {
      if (this.offset + amount > this._buffer.length) {
        throw new DeserializerError(`Found End-Of-Buffer, expecting ${amount} byte(s).`, "UnexpectedEndOfBuffer" /* UnexpectedEndOfBuffer */);
      }
    }
  };
  var Deserializer = _Deserializer;
  __name(Deserializer, "Deserializer");
  Deserializer._textDecoder = new TextDecoder();

  // src/lib/errors/SerializerError.ts
  var SerializerError = class extends Error {
    constructor(message, kind) {
      super(message);
      this.kind = kind;
    }
  };
  __name(SerializerError, "SerializerError");
  var SerializerReason = /* @__PURE__ */ ((SerializerReason2) => {
    SerializerReason2["UnsupportedType"] = "UnsupportedType";
    SerializerReason2["UnsupportedSerializedType"] = "UnsupportedSerializedType";
    SerializerReason2["UnexpectedNullValue"] = "UnexpectedNullValue";
    return SerializerReason2;
  })(SerializerReason || {});

  // src/lib/Serializer.ts
  var MIN_INT8 = -127;
  var MAX_INT8 = 255;
  var MIN_INT32 = -2147483647;
  var MAX_INT32 = 4294967295;
  var float64Array2 = new Float64Array(1);
  var uInt8Float64Array2 = new Uint8Array(float64Array2.buffer);
  var _Serializer = class {
    constructor(data, onUnsupported = null) {
      this._buffer = new Uint8Array(16);
      this._offset = 0;
      this._objectIDs = /* @__PURE__ */ new Map();
      this._handlingUnsupported = false;
      this._data = data;
      this.onUnsupported = onUnsupported;
    }
    process() {
      this.parse(this._data);
      const temp = this._buffer.subarray(0, this._offset);
      this._data = null;
      this._offset = 0;
      this._objectIDs.clear();
      this._buffer = null;
      return temp;
    }
    parse(value, hint = typeof value) {
      switch (hint) {
        case "bigint" /* BigInt */:
          return this.parseBigInt(value);
        case "boolean" /* Boolean */:
          return this.parseBoolean(value);
        case "number" /* Number */:
          return this.parseNumber(value);
        case "object" /* Object */:
          return this.parseObject(value);
        case "string" /* String */:
          return this.parseString(value);
        case "undefined" /* Undefined */:
          return this.parseUndefined();
        default:
          return this.handleUnsupported(value, hint);
      }
    }
    handleUnsupported(value, hint) {
      if (this.onUnsupported) {
        if (this._handlingUnsupported) {
          throw new SerializerError("The modified value was not serializable.", "UnsupportedSerializedType" /* UnsupportedSerializedType */);
        }
        this._handlingUnsupported = true;
        this.parse(this.onUnsupported(value));
        this._handlingUnsupported = false;
        return;
      }
      throw new SerializerError(`Unsupported type '${hint}'.`, "UnsupportedType" /* UnsupportedType */);
    }
    parseBigInt(value) {
      const sign = value >= BigIntegers.ZERO ? 0 : 1;
      this.ensureAlloc(5);
      this.write8(sign ? 4 /* NBigInt */ : 3 /* PBigInt */);
      const headerOffset = this._offset;
      this._offset += 4;
      let unsignedBigInt = sign === 1 ? -value : value;
      let byteCount = 0;
      while (unsignedBigInt > 0) {
        ++byteCount;
        this.write8(Number(unsignedBigInt & BigIntegers.BYTE));
        unsignedBigInt >>= BigIntegers.EIGHT;
      }
      this.write32At(byteCount, headerOffset);
    }
    parseBoolean(value) {
      this.write8(5 /* Boolean */);
      this.write8(value ? 1 : 0);
    }
    parseNumber(value) {
      const type = this.getNumberType(value);
      this.write8(type);
      switch (type) {
        case 9 /* SignedByte */:
          this.write8(-value);
          break;
        case 8 /* UnsignedByte */:
          this.write8(value);
          break;
        case 11 /* SignedInt32 */:
          this.write32(-value);
          break;
        case 10 /* UnsignedInt32 */:
          this.write32(value);
          break;
        case 13 /* SignedFloat64 */:
          this.writeF64(-value);
          break;
        case 12 /* UnsignedFloat64 */:
          this.writeF64(value);
          break;
        default:
          throw new Error(`Unreachable code. Got unexpected integer type ${type}`);
      }
    }
    parseObject(value) {
      if (value === null)
        return this.parseValueNull();
      const id = this._objectIDs.get(value);
      if (typeof id === "number")
        return this.parseValueReference(id);
      this._objectIDs.set(value, this._objectIDs.size);
      if (Array.isArray(value))
        return this.parseValueArray(value);
      const tag = Object.prototype.toString.call(value);
      switch (tag) {
        case "[object String]":
          return this.parseValueObjectString(value);
        case "[object Boolean]":
          return this.parseValueObjectBoolean(value);
        case "[object Number]":
          return this.parseValueObjectNumber(value);
        case "[object Date]":
          return this.parseValueObjectDate(value);
        case "[object RegExp]":
          return this.parseValueObjectRegExp(value);
        case "[object Object]":
          return this.parseValueObjectLiteral(value);
        case "[object Map]":
          return this.parseValueObjectMap(value);
        case "[object Set]":
          return this.parseValueObjectSet(value);
        case "[object ArrayBuffer]":
          return this.parseValueObjectArrayBuffer(value);
        case "[object WeakMap]":
          return this.parseValueObjectWeakMap();
        case "[object WeakSet]":
          return this.parseValueObjectWeakSet();
        case "[object Promise]":
          return this.handleUnsupported(value, "object");
        default:
          return this.parseValueObjectFallback(value, tag);
      }
    }
    parseString(value) {
      this.write8(6 /* String */);
      this.writeValueString(value);
    }
    parseUndefined() {
      this.write8(7 /* Undefined */);
    }
    parseValueNull() {
      this.write8(2 /* Null */);
    }
    parseValueObjectString(value) {
      this.write8(20 /* StringObject */);
      this.writeValueString(value.valueOf());
    }
    parseValueObjectBoolean(value) {
      this.write8(18 /* BooleanObject */);
      this.write8(value.valueOf() ? 1 : 0);
    }
    parseValueObjectNumber(value) {
      this.write8(19 /* NumberObject */);
      this.writeF64(value.valueOf());
    }
    parseValueObjectDate(value) {
      this.write8(17 /* Date */);
      this.writeF64(value.valueOf());
    }
    parseValueObjectRegExp(value) {
      this.write8(23 /* RegExp */);
      this.writeValueString(value.source);
      this.write8(RegExps.flagsAsInteger(value));
    }
    parseValueObjectLiteral(value) {
      const keys = Object.keys(value);
      if (keys.length === 0) {
        return this.write8(21 /* EmptyObject */);
      }
      this.write8(22 /* Object */);
      for (const entryKey of keys) {
        this.parse(entryKey);
        this.parse(value[entryKey]);
      }
      this.write8(0 /* NullPointer */);
    }
    parseValueObjectMap(value) {
      if (value.size === 0) {
        return this.write8(25 /* EmptyMap */);
      }
      this.write8(24 /* Map */);
      for (const [entryKey, entryValue] of value.entries()) {
        this.parse(entryKey);
        this.parse(entryValue);
      }
      this.write8(0 /* NullPointer */);
    }
    parseValueObjectSet(value) {
      if (value.size === 0) {
        return this.write8(28 /* EmptySet */);
      }
      this.write8(27 /* Set */);
      for (const entryValue of value) {
        this.parse(entryValue);
      }
      this.write8(0 /* NullPointer */);
    }
    parseValueObjectArrayBuffer(value) {
      this.write8(30 /* ArrayBuffer */);
      const uint8Array = new Uint8Array(value);
      this.write32(uint8Array.length);
      this.write(uint8Array);
    }
    parseValueObjectWeakMap() {
      this.write8(26 /* WeakMap */);
    }
    parseValueObjectWeakSet() {
      this.write8(29 /* WeakSet */);
    }
    parseValueObjectFallback(value, tag) {
      const typedArrayTag = TypedArrays.typedArrayTags.get(tag);
      if (typedArrayTag)
        this.writeValueTypedArray(value, typedArrayTag);
      else
        this.parseValueObjectLiteral(value);
    }
    parseValueReference(value) {
      this.write8(16 /* ObjectReference */);
      this.write32(value);
    }
    parseValueArray(value) {
      if (value.length === 0) {
        return this.write8(15 /* EmptyArray */);
      }
      this.ensureAlloc(2);
      this.write8(14 /* Array */);
      for (let i = 0, n = value.length; i < n; i++) {
        if (i in value) {
          this.parse(value[i]);
        } else {
          this.write8(1 /* Hole */);
        }
      }
      this.write8(0 /* NullPointer */);
    }
    writeValueTypedArray(value, tag) {
      this.write8(tag);
      this.write32(value.byteLength);
      if (tag !== 32 /* Uint8Array */) {
        value = new Uint8Array(value.buffer);
      }
      this.write(value);
    }
    write(value) {
      this.ensureAlloc(value.byteLength);
      this._buffer.set(value, this._offset);
      this._offset += value.byteLength;
    }
    write8(value) {
      this.ensureAlloc(1);
      this._buffer[this._offset++] = value;
    }
    write32(value) {
      this.ensureAlloc(4);
      this.write32At(value, this._offset);
      this._offset += 4;
    }
    write32At(value, offset) {
      this._buffer[offset + 3] = value;
      value >>>= 8;
      this._buffer[offset + 2] = value;
      value >>>= 8;
      this._buffer[offset + 1] = value;
      value >>>= 8;
      this._buffer[offset] = value;
    }
    writeF64(value) {
      float64Array2[0] = value;
      this.write(uInt8Float64Array2);
    }
    writeValueString(value) {
      const serialized = _Serializer._textEncoder.encode(value);
      if (serialized.includes(0 /* NullPointer */)) {
        throw new SerializerError("Unexpected null pointer in serialized string.", "UnexpectedNullValue" /* UnexpectedNullValue */);
      }
      this.write(serialized);
      this.write8(0 /* NullPointer */);
    }
    getNumberType(value) {
      const sign = value < 0;
      if (value % 1 === 0) {
        if (value >= MIN_INT8 && value <= MAX_INT8)
          return sign ? 9 /* SignedByte */ : 8 /* UnsignedByte */;
        if (value >= MIN_INT32 && value <= MAX_INT32)
          return sign ? 11 /* SignedInt32 */ : 10 /* UnsignedInt32 */;
      }
      return sign ? 13 /* SignedFloat64 */ : 12 /* UnsignedFloat64 */;
    }
    ensureAlloc(amount) {
      this.expandBuffer(this._offset + amount);
    }
    expandBuffer(length) {
      if (this._buffer.length < length) {
        const old = this._buffer;
        this._buffer = new Uint8Array(Numbers.nextPowerOfTwo(length));
        this._buffer.set(old);
      }
    }
  };
  var Serializer = _Serializer;
  __name(Serializer, "Serializer");
  Serializer._textEncoder = new TextEncoder();

  // src/index.ts
  function serialize(data, onUnsupported) {
    return new Serializer(data, onUnsupported).process();
  }
  __name(serialize, "serialize");
  function deserialize(buffer, offset = -1) {
    const deserializer = new Deserializer(buffer);
    if (offset !== -1)
      deserializer.offset = offset;
    const value = deserializer.read();
    deserializer.clean();
    return value;
  }
  __name(deserialize, "deserialize");
  function deserializeWithMetadata(buffer, offset = -1) {
    const deserializer = new Deserializer(buffer);
    if (offset !== -1)
      deserializer.offset = offset;
    const value = deserializer.read();
    const bufferOffset = deserializer.offset;
    deserializer.clean();
    return {
      value,
      offset: bufferOffset === buffer.byteLength ? -1 : bufferOffset
    };
  }
  __name(deserializeWithMetadata, "deserializeWithMetadata");
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=index.global.js.map